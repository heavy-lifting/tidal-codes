d2 $ sound "<bskick:1 bskick:1(3,8)>" # shape 0.6 # gain 1.2

d3 $ jux (hurry 2. iter 2) $ chunk 4 (chop 4)
$ sound "emufx*4" # up (scale "ritusen" "<1 3 5>" - 24) # cut 1

d4 $ jux (slow 2.iter 4) $ sound "{~, 9hh(5,8,<0 1 2>), ~ ~ 9cp}" # legato 0.5 # pan rand

once $ sound "st" # gain 1.2

d5 $ chop "<1 2 4 4 8>" $ density "<1>" $ loopAt "[4,2,8]" $ sound "st:2 st:6"

once $ sound "mb:2"

d1 $ loopAt 16 $ sound "heli:1*4" # gain 1.8 # cut 3

hush

d8 $ sometimes (# n "2 3") $ sound "bb bb/2" # shape 0.2 # gain 1.2

d7 $ bump "hi" 8 "{f!30 t!2}%8" $  sound "cpu(5,8)" # n (irand 8)

d5 $ loopAt "<2 4>" $ sound "mmw"

d6 $ bump "no" 8 "{f!31 t}%8" $ jux (iter 4) $ sound "mmch:8(5,8)"
# legato 1 # up (scale "ritusen" (round <$> range 1 8 saw) - 12)

d1 $ sometimes (# up (scale "ritusen" (round <$> range 1 8 saw)))
$ chunk 4 (hurry (slow 4 $ range 1 8 saw))
$ sound "9rs*8?"

import Data.Map.Strict as Map

bump :: String -> Integer -> Pattern Bool -> ControlPattern -> ControlPattern
bump name bpc bpat pat = (Pattern $ \state -> query (maybe (bumper `overlay` pat) f $ (Map.lookup name $ controls state) >>= getR) state)
  where f t = rotL t (bumper `overlay` pat)
        bumper :: ControlPattern
        bumper = (outerJoin $ (const $ pure $ Map.singleton ("__" ++ name) $ VState statef) <$> (filterOnsets $ filterValues id (rotL (1%bpc) bpat)))
          where statef :: ValueMap -> (ValueMap, Value)
                statef sMap = (Map.insert name v sMap, v)
                  where v = VR $ maybe 0 (+(1%bpc)) $ Map.lookup name sMap >>= getR
