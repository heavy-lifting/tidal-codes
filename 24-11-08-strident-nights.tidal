setcps (140/60/4)

hush

d12 $ midicmd "midiClock*48" # s "[mf]" # midichan "0"

d10 $ (0.05 ~>)
  $ slow 2
  $ sound "vkl"
  # note (scale "dorian" "0 1 4 2" - 24)
  # legato "<0.125>"
  # midichan "0"

d11 $ (0.05 ~>)
  $ sound "vt*4"
  # note (scale "dorian" (run 8) + "<0 3 7 5>" - 24)
  # legato "<0.5>"
  # midichan "0"

d2 $ chunk 4 (hurry 2) $ off (1/4) (|+ n "<7 12>").(chop 4) $ up (scale "dorian" "<0 4>") # sound "vkl:3 vkb" # legato 0.5

d7 silence

d7$ jux (iter 4) $ fast "<1 1 2 4 8>" $ loopAt "<4 8 16 2>" $ chop "<16 8 8>" $ sound "heli heli" # cut 1

all $ (chop 16).(slow "<1 1 1 4> ").(degradeBy 0.4).(chunk 4 (hurry 4))

d8 $ chop 2 $ sound "davadaporan(3,8)" # n (irand 4) # gain 1.3

d9 $ chop 8 $ sound "speak" # gain 0.8 # n (irand 60) # pan (slow 4 $ sine)

--bump
import Data.Map.Strict as Map

bump :: String -> Integer -> Pattern Bool -> ControlPattern -> ControlPattern
bump name bpc bpat pat = (Pattern $ \state -> query (maybe (bumper `overlay` pat) f $ (Map.lookup name $ controls state) >>= getR) state)
  where f t = rotL t (bumper `overlay` pat)
        bumper :: ControlPattern
        bumper = (outerJoin $ (const $ pure $ Map.singleton ("__" ++ name) $ VState statef) <$> (filterOnsets $ filterValues id (rotL (1%bpc) bpat)))
          where statef :: ValueMap -> (ValueMap, Value)
                statef sMap = (Map.insert name v sMap, v)
                  where v = VR $ maybe 0 (+(1%bpc)) $ Map.lookup name sMap >>= getR


st:7 - train
st: 10 - ex
st: 11 - fruit
